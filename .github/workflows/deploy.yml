name: Deploy to Digital Ocean

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install Python dependencies
        working-directory: ./api
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Wait for database
        run: |
          until pg_isready -h localhost -p 5432 -U postgres; do
            echo "Waiting for database..."
            sleep 2
          done

      - name: Run backend tests
        working-directory: ./api
        env:
          SECRET_KEY: test-secret-key-for-ci-only-min-50-chars-long
          DEBUG: 1
          DJANGO_ALLOWED_HOSTS: localhost
          SQL_ENGINE: django.db.backends.postgresql
          SQL_DATABASE: test_db
          SQL_USER: postgres
          SQL_PASSWORD: postgres
          SQL_HOST: localhost
          SQL_PORT: 5432
          CELERY_BROKER_URL: redis://localhost:6379/0
          CELERY_RESULT_BACKEND: redis://localhost:6379
          DJANGO_SETTINGS_MODULE: paperwaves.settings
        run: |
          python manage.py check
          python manage.py migrate
          pytest -v --tb=short -x

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run frontend tests
        working-directory: ./frontend
        run: npm run test:run

  deploy:
    name: Deploy to Digital Ocean
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        timeout-minutes: 15
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          SQL_PASSWORD: ${{ secrets.SQL_PASSWORD }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          DEBUG_IP_ADDRESS: ${{ secrets.DEBUG_IP_ADDRESS }}
          DEBUG_MODE: ${{ secrets.DEBUG_MODE }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USER }}
          key: ${{ secrets.DO_SSH_KEY }}
          script_stop: true
          debug: true
          script: |
            set -e
            set -x

            # Determine docker-compose command
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE="docker-compose"
            elif docker compose version &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            else
              echo "Error: docker-compose not found!"
              exit 1
            fi

            # Navigate to project directory
            cd ~/scaling-engine || cd /root/scaling-engine || { echo "Error: Could not find project directory"; exit 1; }

            # Pull latest code
            git pull origin master

            # Verify required secrets are set
            if [ -z "${SECRET_KEY:-}" ]; then
              echo "Error: SECRET_KEY secret is not set!"
              exit 1
            fi
            if [ -z "${SQL_PASSWORD:-}" ]; then
              echo "Error: SQL_PASSWORD secret is not set!"
              exit 1
            fi

            # Determine DEBUG mode: enable if DEBUG_IP_ADDRESS or DEBUG_MODE is set
            # DEBUG_IP_ADDRESS enables debug mode with IP restriction
            # DEBUG_MODE is a simple on/off switch for staging/early development
            DEBUG_VALUE="0"
            if [ -n "${DEBUG_IP_ADDRESS:-}" ]; then
              DEBUG_VALUE="1"
              echo "Debug mode enabled for IP: ${DEBUG_IP_ADDRESS}"
            fi
            # Check DEBUG_MODE separately (using || true to avoid set -e issues)
            if [ "${DEBUG_MODE:-}" = "1" ]; then
              DEBUG_VALUE="1"
              echo "Debug mode enabled via DEBUG_MODE secret"
            fi
            if [ "${DEBUG_VALUE}" = "0" ]; then
              echo "Debug mode disabled (production mode)"
            fi

            # Generate .env.prod
            {
              echo "# Django Settings"
              echo "DEBUG=${DEBUG_VALUE}"
              echo "SECRET_KEY=${SECRET_KEY}"
              echo "DJANGO_ALLOWED_HOSTS=159.65.18.16,209.38.161.55,web,localhost,radioreads.fun,www.radioreads.fun"
              echo ""
              echo "# Database Settings"
              echo "SQL_ENGINE=django.db.backends.postgresql"
              echo "SQL_DATABASE=paperwaves_prod"
              echo "SQL_USER=paperwaves_user"
              echo "SQL_PASSWORD=${SQL_PASSWORD}"
              echo "SQL_HOST=db"
              echo "SQL_PORT=5432"
              echo ""
              echo "# Celery Settings"
              echo "CELERY_BROKER_URL=redis://redis:6379/0"
              echo "CELERY_RESULT_BACKEND=redis://redis:6379"
              echo ""
              echo "# AI / Book Extraction"
              echo "BOOK_EXTRACTION_MODE=ai"
            } > .env.prod

            # Add ANTHROPIC_API_KEY if provided
            if [ -n "${ANTHROPIC_API_KEY}" ]; then
              echo "ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}" >> .env.prod
            fi

            # Add DEBUG_IP_ADDRESS if provided (for IP-based debug access)
            if [ -n "${DEBUG_IP_ADDRESS}" ]; then
              echo "DEBUG_IP_ADDRESS=${DEBUG_IP_ADDRESS}" >> .env.prod
            fi

            # Generate .env.prod.db
            {
              echo "# PostgreSQL Database Configuration"
              echo "POSTGRES_USER=paperwaves_user"
              echo "POSTGRES_PASSWORD=${SQL_PASSWORD}"
              echo "POSTGRES_DB=paperwaves_prod"
            } > .env.prod.db

            # Verify .env files exist and have content
            echo "Verifying .env files..."
            if [ ! -f .env.prod ] || [ ! -s .env.prod ]; then
              echo "Error: .env.prod is missing or empty"
              exit 1
            fi
            if [ ! -f .env.prod.db ] || [ ! -s .env.prod.db ]; then
              echo "Error: .env.prod.db is missing or empty"
              exit 1
            fi
            # Verify SQL_PASSWORD is in .env.prod (show masked)
            if grep -q "SQL_PASSWORD=" .env.prod; then
              PASSWORD_LENGTH=$(grep "SQL_PASSWORD=" .env.prod | cut -d= -f2 | wc -c)
              echo "âœ… .env files verified (SQL_PASSWORD length: $((PASSWORD_LENGTH-1)) chars)"
            else
              echo "Error: SQL_PASSWORD not found in .env.prod"
              exit 1
            fi

            # Use docker-compose.react.yml for deployment
            COMPOSE_FILE="docker-compose.react.yml"

            # Stop existing containers (remove volumes to ensure clean state)
            echo "Stopping existing containers..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE down || true

            # Build containers
            echo "Building containers..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE build

            # Start containers (force recreate to pick up new env files)
            # Note: env_file is read when containers start, so files must exist before this
            echo "Starting containers..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE up -d --force-recreate --remove-orphans

            # Wait for containers to be up
            echo "Waiting for containers to start..."
            sleep 10

            # Verify environment variables are loaded in web container
            echo "Checking environment variables in web container..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE exec -T web sh -c 'echo "SQL_PASSWORD is: ${SQL_PASSWORD:+SET}"' || echo "Warning: Could not check env vars"

            # Wait for database to be ready (max 60 seconds)
            echo "Waiting for database to be ready..."
            for i in {1..30}; do
              # Check if web container is running first
              if $DOCKER_COMPOSE -f $COMPOSE_FILE ps web | grep -q "Up"; then
                # Then check database connection
                if $DOCKER_COMPOSE -f $COMPOSE_FILE exec -T web python manage.py check --database default 2>/dev/null; then
                  echo "Database is ready"
                  break
                else
                  # Show the actual error
                  echo "Database check failed, attempt $i/30"
                  $DOCKER_COMPOSE -f $COMPOSE_FILE exec -T web python manage.py check --database default 2>&1 | head -5 || true
                fi
              fi
              if [ $i -eq 30 ]; then
                echo "Database not ready after 60 seconds"
                echo "Container status:"
                $DOCKER_COMPOSE -f $COMPOSE_FILE ps
                echo "Web container logs:"
                $DOCKER_COMPOSE -f $COMPOSE_FILE logs web | tail -20
                echo "Checking .env.prod file:"
                ls -la .env.prod* || echo "No .env files found"
                exit 1
              fi
              sleep 2
            done

            # Run migrations
            echo "Running migrations..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE exec -T web python manage.py migrate --noinput

            # Collect static files
            echo "Collecting static files..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE exec -T web python manage.py collectstatic --noinput

            # Show container status
            $DOCKER_COMPOSE -f $COMPOSE_FILE ps

            echo "Deployment complete!"
